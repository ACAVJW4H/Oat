//******************************************************************************
//* File:   Aruco.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//****************************************************************************

#include "OatConfig.h" // Generated by CMake

#include <cmath>
#include <string>
#include <opencv2/aruco.hpp>
#include <opencv2/cvconfig.h>
#include <opencv2/opencv.hpp>
#include <cpptoml.h>

#include "../../lib/datatypes/Position2D.h"
#include "../../lib/utility/IOFormat.h"
#include "../../lib/utility/TOMLSanitize.h"

#include "DetectorFunc.h"
#include "Aruco.h"

namespace oat {

Aruco::Aruco(const std::string &frame_source_address,
             const std::string &position_sink_address) :
  PositionDetector(frame_source_address, position_sink_address)
{
    detection_params_ = cv::aruco::DetectorParameters::create(); 
    marker_dict_ = cv::aruco::getPredefinedDictionary(marker_dict_id_);
}

void Aruco::detectPosition(cv::Mat &frame, oat::Position2D &position) {

    std::vector<int> marker_ids;
    std::vector< std::vector<cv::Point2f> > marker_corners;
    cv::aruco::detectMarkers(frame, 
                             marker_dict_, 
                             marker_corners, 
                             marker_ids, 
                             detection_params_);

    for (std::vector<int>::size_type i = 0; i < marker_ids.size(); i++) {

        // Get position if correct marker is found
        if (marker_ids[i] == marker_id_) {

            position.position_valid = true;
            position.heading_valid = true;

            oat::Point2D center =  
                0.5 * (marker_corners[i][0] + marker_corners[i][2]);           
            position.position = center;

            // For some reason, I cannot subtract 
            // cv::Point2d - cv::Point2f directly
            position.heading.x = center.x - 
                marker_corners[i][static_cast<size_t>(heading_dir_)].x;
            position.heading.y = center.y - 
                marker_corners[i][static_cast<size_t>(heading_dir_)].y;

            double mag = std::sqrt(
                    std::pow(position.heading.x, 2.0) +
                    std::pow(position.heading.y, 2.0));

            position.heading = position.heading/mag;

            break;
        }
    }
}

void Aruco::configure(const std::string& config_file,
                      const std::string& config_key) {

    // Available options
    std::vector<std::string> options {"marker-id"};

    // This will throw cpptoml::parse_exception if a file
    // with invalid TOML is provided
    auto config = cpptoml::parse_file(config_file);

    // See if a camera configuration was provided
    if (config->contains(config_key)) {

        // Get this components configuration table
        auto this_config = config->get_table(config_key);

        // Check for unknown options in the table and throw if you find them
        oat::config::checkKeys(options, this_config);

        // Marker ID to look for
        {
            int64_t val;
            oat::config::getValue(this_config, "marker-id", val, (int64_t)0);
            marker_id_ = val;
        }

    } else {
        throw (std::runtime_error(oat::configNoTableError(config_key, config_file)));
    }
}

} /* namespace oat */
