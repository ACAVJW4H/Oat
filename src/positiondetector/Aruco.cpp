//******************************************************************************
//* File:   Aruco.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//****************************************************************************

#include "OatConfig.h" // Generated by CMake

#include <cmath>
#include <string>
#include <opencv2/aruco.hpp>
#include <opencv2/cvconfig.h>
#include <opencv2/opencv.hpp>
#include <cpptoml.h>

#include "../../lib/datatypes/Position2D.h"
#include "../../lib/utility/IOFormat.h"
#include "../../lib/utility/TOMLSanitize.h"

#include "DetectorFunc.h"
#include "Aruco.h"

namespace oat {

Aruco::Aruco(const std::string &frame_source_address,
             const std::string &position_sink_address) :
  PositionDetector(frame_source_address, position_sink_address)
{
    // Nothing
    // HACK HACK HACK
    //auto dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);
    //for (int i = 0; i < 250; i++) {
    //    cv::Mat markerImage;
    //    cv::aruco::drawMarker(dictionary, i, 50, markerImage, 1);
    //    cv::imshow("test", markerImage);
    //    cv::waitKey(0);
    //}
}

void Aruco::detectPosition(cv::Mat &frame, oat::Position2D &position) {

    cv::Mat imageCopy;
    frame.copyTo(imageCopy);

    // TODO: Add dectection parameters
    // TODO: Add position_loc_
    // TODO: cv::aruco::DICT_6X6_250 should be parameter

    // TODO: Sould be a frame filter
    //cv::equalizeHist(frame, frame);

    std::vector<int> marker_ids;
    std::vector< std::vector<cv::Point2f> > marker_corners;
    auto parameters = cv::aruco::DetectorParameters::create();
    auto dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);
    cv::aruco::detectMarkers(frame, dictionary, marker_corners, marker_ids, parameters);

    //cv::aruco::drawDetectedMarkers(imageCopy, marker_corners, marker_ids);
    //cv::imshow("out", imageCopy);
    //cv::waitKey(1);

    for (std::vector<int>::size_type i = 0; i < marker_ids.size(); i++) {

        if (marker_ids[i] == marker_id_) {

            position.position_valid = true;
            position.heading_valid = true;

            oat::Point2D center =  
                0.5 * (marker_corners[i][0] + marker_corners[i][2]);           
            position.position = center;
            // TODO: for some reason, I cannot subrract cv::Point2d -
            // cv::Point2f directly
            position.heading.x = center.x - 
                marker_corners[i][static_cast<size_t>(heading_dir_)].x;
            position.heading.y = center.y - 
                marker_corners[i][static_cast<size_t>(heading_dir_)].y;

            double mag = std::sqrt(
                    std::pow(position.heading.x, 2.0) +
                    std::pow(position.heading.y, 2.0));

            position.heading = position.heading/mag;

            break;
        }
    }
}

void Aruco::configure(const std::string& config_file,
                      const std::string& config_key) {

    // Available options
    std::vector<std::string> options {"marker-id"};

    // This will throw cpptoml::parse_exception if a file
    // with invalid TOML is provided
    auto config = cpptoml::parse_file(config_file);

    // See if a camera configuration was provided
    if (config->contains(config_key)) {

        // Get this components configuration table
        auto this_config = config->get_table(config_key);

        // Check for unknown options in the table and throw if you find them
        oat::config::checkKeys(options, this_config);

        // Marker ID to look for
        {
            int64_t val;
            oat::config::getValue(this_config, "marker-id", val, (int64_t)0, (int64_t)250);
            marker_id_ = val;
        }

    } else {
        throw (std::runtime_error(oat::configNoTableError(config_key, config_file)));
    }
}

} /* namespace oat */
