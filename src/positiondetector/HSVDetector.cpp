//******************************************************************************
//* File:   HSVDetector.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//****************************************************************************

#include "OatConfig.h" // Generated by CMake

#include <string>
#include <limits>
//#include <math.h>
#include <opencv2/opencv.hpp>
//#include <cmath>
#include <cpptoml.h>

#include "../../lib/datatypes/Position2D.h"

#include "../../lib/utility/IOFormat.h"
#include "../../lib/utility/OatTOMLSanitize.h"

#include "HSVDetector.h"

namespace oat {

HSVDetector::HSVDetector(const std::string &frame_source_address,
                         const std::string &position_sink_address) :
  PositionDetector(frame_source_address, position_sink_address)
, tuning_image_title_(position_sink_address + "_tuning")
{
    // Set defaults for the erode and dilate blocks
    // Cannot use initializer because if these are set to 0, erode_on or
    // dilate_on must be set to false
    set_erode_size(0);
    set_dilate_size(10);
}

oat::Position2D HSVDetector::detectPosition(cv::Mat &frame) {

    // Transform frame to HSV
    cv::cvtColor(frame, frame, cv::COLOR_BGR2HSV);

    // Threshold HSV channels
    cv::inRange(frame,
                cv::Scalar(h_min_, s_min_, v_min_),
                cv::Scalar(h_max_, s_max_, v_max_),
                threshold_frame_);

    // Filter the resulting threshold image
    if (erode_on_)
        cv::erode(threshold_frame_, threshold_frame_, erode_element_);

    if (dilate_on_)
        cv::dilate(threshold_frame_, threshold_frame_, dilate_element_);

    // Threshold frame will be destroyed by the transform below, so we need to use
    // it to form the frame that will be shown in the tuning window here
    if (tuning_on_)
         frame.setTo(0, threshold_frame_ == 0);

    // Find the largest contour in the threshold image
    siftContours(threshold_frame_,
                 object_position_,
                 min_object_area_,
                 max_object_area_);

    // Use the GUI tuner if requested
    tune(frame);

    return object_position_;
}

void HSVDetector::configure(const std::string &config_file, const std::string &config_key) {

    // Available options
    std::vector<std::string> options {"erode",
                                      "dilate",
                                      "min_area",
                                      "max_area",
                                      "h_thresholds",
                                      "s_thresholds",
                                      "v_thresholds",
                                      "tune" };

    // This will throw cpptoml::parse_exception if a file
    // with invalid TOML is provided
   auto config = cpptoml::parse_file(config_file);

    // See if a camera configuration was provided
    if (config->contains(config_key)) {

        // Get this components configuration table
        auto this_config = config->get_table(config_key);

        // Check for unknown options in the table and throw if you find them
        oat::config::checkKeys(options, this_config);

        // Erode
        {
            int64_t val;
            oat::config::getValue(this_config, "erode", val, (int64_t)0);
            set_erode_size(val);

        }

        // Dilate
        {
            int64_t val;
            oat::config::getValue(this_config, "dilate", val, (int64_t)0);
            set_dilate_size(val);
        }

        // Minimum object area
        oat::config::getValue(this_config, "min_area", min_object_area_, 0.0);

        // Maximum object area
        oat::config::getValue(this_config, "max_area", max_object_area_, 0.0);

        // HSV thresholds
        oat::config::Table t;
        if (oat::config::getTable(this_config, "h_thresholds", t)) {

            int64_t val;
            oat::config::getValue(t, "min", val, (int64_t)0, (int64_t)256, true);
            h_min_ = val;
            oat::config::getValue(t, "max", val, (int64_t)0, (int64_t)256, true);
            h_max_ = val;
        }

        if (oat::config::getTable(this_config, "s_thresholds", t)) {

            int64_t val;
            oat::config::getValue(t, "min", val, (int64_t)0, (int64_t)256, true);
            s_min_ = val;
            oat::config::getValue(t, "max", val, (int64_t)0, (int64_t)256, true);
            s_max_ = val;
        }

        if (oat::config::getTable(this_config, "v_thresholds", t)) {

            int64_t val;
            oat::config::getValue(t, "min", val, (int64_t)0, (int64_t)256, true);
            v_min_ = val;
            oat::config::getValue(t, "max", val, (int64_t)0, (int64_t)256, true);
            v_max_ = val;
        }

        // Tuning
        oat::config::getValue(this_config, "tune", tuning_on_);
        if (tuning_on_) {
            createTuningWindows();
        }

    } else {
        throw (std::runtime_error(oat::configNoTableError(config_key, config_file)));
    }
}

void HSVDetector::tune(cv::Mat &image) {

    if (tuning_on_) {
        std::string msg = cv::format("Object not found");

        // Plot a circle representing found object
        if (object_position_.position_valid) {
            auto radius = std::sqrt(object_area_ / PI);
            cv::Point center;
            center.x = object_position_.position.x;
            center.y = object_position_.position.y;
            cv::circle(image, center, radius, cv::Scalar(0, 0, 255), 2);
            msg = cv::format("(%d, %d) pixels",
                    (int) object_position_.position.x,
                    (int) object_position_.position.y);
        }

        int baseline = 0;
        cv::Size textSize = cv::getTextSize(msg, 1, 1, 1, &baseline);
        cv::Point text_origin(
                image.cols - textSize.width - 10,
                image.rows - 2 * baseline - 10);

        cv::putText(image, msg, text_origin, 1, 1, cv::Scalar(0, 255, 0));

        if (!tuning_windows_created_)
            createTuningWindows();

        cv::imshow(tuning_image_title_, image);
        cv::waitKey(1);

    } else if (!tuning_on_ && tuning_windows_created_) {

        // TODO: Window will not actually close!!
        // Destroy the tuning windows
        cv::destroyWindow(tuning_image_title_);
        tuning_windows_created_ = false;
    }
}

void HSVDetector::createTuningWindows() {

#ifdef OAT_USE_OPENGL
    try {
        cv::namedWindow(tuning_image_title_, cv::WINDOW_OPENGL & cv::WINDOW_KEEPRATIO);
    } catch (cv::Exception& ex) {
        whoWarn(name_, "OpenCV not compiled with OpenGL support. Falling back to OpenCV's display driver.\n");
        cv::namedWindow(name_, cv::WINDOW_NORMAL & cv::WINDOW_KEEPRATIO);
    }
#else
    cv::namedWindow(tuning_image_title_, cv::WINDOW_NORMAL);
#endif

    // Create sliders and insert them into window
    cv::createTrackbar("H MIN", tuning_image_title_, &h_min_, 256);
    cv::createTrackbar("H MAX", tuning_image_title_, &h_max_, 256);
    cv::createTrackbar("S MIN", tuning_image_title_, &s_min_, 256);
    cv::createTrackbar("S MAX", tuning_image_title_, &s_max_, 256);
    cv::createTrackbar("V MIN", tuning_image_title_, &v_min_, 256);
    cv::createTrackbar("V MAX", tuning_image_title_, &v_max_, 256);
    cv::createTrackbar("MIN AREA", tuning_image_title_, &dummy0, 10000, &hsvDetectorMinAreaSliderChangedCallback, this);
    cv::createTrackbar("MAX AREA", tuning_image_title_, &dummy1, 10000, &hsvDetectorMaxAreaSliderChangedCallback, this);
    cv::createTrackbar("ERODE", tuning_image_title_, &erode_px_, 50, &hsvDetectorErodeSliderChangedCallback, this);
    cv::createTrackbar("DILATE", tuning_image_title_, &dilate_px_, 50, &hsvDetectorDilateSliderChangedCallback, this);

    tuning_windows_created_ = true;
}

void HSVDetector::set_erode_size(int value) {

    if (value > 0) {
        erode_on_ = true;
        erode_px_ = value;
        erode_element_ = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(erode_px_, erode_px_));
    } else {
        erode_on_ = false;
    }
}

void HSVDetector::set_dilate_size(int value) {
    if (value > 0) {
        dilate_on_ = true;
        dilate_px_ = value;
        dilate_element_ = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(dilate_px_, dilate_px_));
    } else {
        dilate_on_ = false;
    }
}

// Non-member helper functions

void siftContours(cv::Mat &frame, Position2D &position, double min_area, double max_area) {

    std::vector<std::vector <cv::Point> > contours;

    // NOTE: This function will modify the frame
    cv::findContours(frame, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

    double object_area = 0;
    double countour_area = 0;
    position.position_valid = false;

    for (auto &c : contours) {

        cv::Moments moment = cv::moments(static_cast<cv::Mat>(c));
        countour_area = moment.m00;

        // Isolate the largest contour within the min/max range.
        if (countour_area > min_area &&
                countour_area < max_area &&
                countour_area > object_area) {

            position.position.x = moment.m10 / countour_area;
            position.position.y = moment.m01 / countour_area;
            position.position_valid = true;
            object_area = countour_area;
        }
    }
}

void hsvDetectorMinAreaSliderChangedCallback(int value, void * object) {
    HSVDetector * hsv_detector = (HSVDetector *) object;
    hsv_detector->set_min_object_area(static_cast<double>(value));
}

void hsvDetectorMaxAreaSliderChangedCallback(int value, void * object) {
    HSVDetector * hsv_detector = (HSVDetector *) object;
    hsv_detector->set_max_object_area(static_cast<double>(value));
}

void hsvDetectorErodeSliderChangedCallback(int value, void * object) {
    HSVDetector * hsv_detector = (HSVDetector *) object;
    hsv_detector->set_erode_size(value);
}

void hsvDetectorDilateSliderChangedCallback(int value, void * object) {
    HSVDetector * hsv_detector = (HSVDetector *) object;
    hsv_detector->set_dilate_size(value);
}

} /* namespace oat */

// NOTE: This code was from a leftover functional CUDA implementation that did not
// give me the performance gains I was hoping for. I'm leaving it here in case
// I figure something out that changes my mind about it.
//
//#ifdef NOIMP_OAT_USE_CUDA
//#include <opencv2/core/cuda.hpp>
//#include <opencv2/cudaarithm.hpp>
//#include <opencv2/cudafilters.hpp>
//#include <opencv2/cudaimgproc.hpp>
//#endif
//
//#ifdef NOIMP_OAT_USE_CUDA
//    createHSVLUT();
//#endif
//#ifdef NOIMP_OAT_USE_CUDA
//    cv::cuda::GpuMat hsv_image_, lut_frame, threshold_frame_;
//    cv::Mat search_frame;
//    cv::Mat tuning_image;
//    std::vector<cv::cuda::GpuMat> hsv_channels;
//    cv::Ptr<cv::cuda::LookUpTable> hsv_lut;
//    cv::Ptr<cv::cuda::Filter> erode_filter;
//    cv::Ptr<cv::cuda::Filter> dilate_filter;
//
//void hsvThreshold(cv::Mat &in, cv::Mat &out,
//        const &cv::Scalar min, const &cv::Scalar max) {
//
//#ifdef NOIMP_OAT_USE_CUDA
//    hsv_lut->transform(hsv_image_, lut_frame);
//
//    std::vector<cv::cuda::GpuMat> channels;
//    cv::cuda::split(lut_frame, channels);
//    cv::cuda::bitwise_and(channels[0], channels[1], threshold_frame_);
//    cv::cuda::bitwise_and(channels[2], threshold_frame_, threshold_frame_);
//#endif
//}

//void HSVDetector::erodeDilate(cv::Mat &frame_io, cv::Mat &eroder, cv::Mat &dilator) {
//
//#ifdef NOIMP_OAT_USE_CUDA
//    if (erode_on_)
//        erode_filter->apply(frame_io, frame_io);
//
//    if (dilate_on_)
//        dilate_filter->apply(frame_io, frame_io);
//#endif
//}
//
//
//void HSVDetector::createHSVLUT() {
//
//    std::vector<cv::Mat> lut_channels;
//
//    lut_channels.push_back(cv::Mat(256, 1, CV_8UC1, cv::Scalar(0)));
//    if (h_min < h_max) {
//        auto h_inc = lut_channels[0].rowRange(h_min, h_max);
//        h_inc.setTo(cv::Scalar(1));
//    }
//
//    lut_channels.push_back(cv::Mat(256, 1, CV_8UC1, cv::Scalar(0)));
//    if (s_min < s_max) {
//        auto s_inc = lut_channels[1].rowRange(s_min, s_max);
//        s_inc.setTo(cv::Scalar(1));
//    }
//
//    lut_channels.push_back(cv::Mat(256, 1, CV_8UC1, cv::Scalar(0)));
//    if (v_min < v_max) {
//        auto v_inc = lut_channels[2].rowRange(v_min, v_max);
//        v_inc.setTo(cv::Scalar(1));
//    }
//
//    cv::Mat lut;
//    cv::merge(lut_channels, lut);
//    hsv_lut = cv::cuda::createLookUpTable(lut);
//
//}
//
//void HSVDetector::set_erode_size(int value) {
//
//    if (value > 0) {
//        erode_on = true;
//        erode_px = value;
//        cv::Mat erode_element =
//            cv::getStructuringElement(cv::MORPH_RECT, cv::Size(erode_px, erode_px));
//        erode_filter =
//            cv::cuda::createMorphologyFilter(cv::MORPH_ERODE, CV_8UC1, erode_element);
//    } else {
//        erode_on = false;
//    }
//}
//
//void HSVDetector::set_dilate_size(int value) {
//    if (value > 0) {
//        dilate_on = true;
//        dilate_px = value;
//        cv::Mat dilate_element =
//            cv::getStructuringElement(cv::MORPH_RECT, cv::Size(dilate_px, dilate_px));
//        dilate_filter =
//            cv::cuda::createMorphologyFilter(cv::MORPH_DILATE, CV_8UC1, dilate_element);
//    } else {
//        dilate_on = false;
//    }
//}
//
//#endif // NOIMP_OAT_USE_CUDA
