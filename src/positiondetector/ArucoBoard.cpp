//******************************************************************************
//* File:   ArucoBoard.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//****************************************************************************

// TODO: Remove
#include <rapidjson/rapidjson.h>
#include <rapidjson/prettywriter.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>

#include "ArucoBoard.h"

#include <cmath>
#include <cpptoml.h>
#include <opencv2/aruco.hpp>
#include <opencv2/cvconfig.h>
#include <opencv2/opencv.hpp>
#include <string>

#include "../../lib/datatypes/Position2D.h"
#include "../../lib/datatypes/Pose.h"
#include "../../lib/utility/IOFormat.h"
#include "../../lib/utility/TOMLSanitize.h"

namespace oat {

ArucoBoard::ArucoBoard(const std::string &frame_source_address,
                       const std::string &position_sink_address)
: PositionDetector(frame_source_address, position_sink_address)
{
    // Set required frame type
    required_color_ = PIX_GREY;
}

void ArucoBoard::appendOptions(po::options_description &opts)
{
    // Accepts a config file
    PositionDetector::appendOptions(opts);

    // Update CLI options
    po::options_description local_opts;
    local_opts.add_options()
        ("dictionary,D", po::value<std::string>(),
         "Aruco board dictionary to use for detection or printing when -p is "
         "defined. Dictionaries are defined by the size of each marker and the "
         "number of markers in the dictionary. These parameters are encoded by "
         "a string of the form:\n\n"
         "  <Size>X<Size>_<Number of Markers>\n\n"
         "Values:\n"
         "  4X4_50\n"
         "  4X4_100\n"
         "  4X4_250\n"
         "  4X4_1000\n"
         "  5X5_50\n"
         "  5X5_100\n"
         "  5X5_250\n"
         "  5X5_1000\n"
         "  6X6_50\n"
         "  6X6_100\n"
         "  6X6_250\n"
         "  6X6_1000\n"
         "  7X7_50\n"
         "  7X7_100\n"
         "  7X7_250\n"
         "  7X7_1000\n\n")
        ("camera-matrix,k", po::value<std::string>(),
         "Nine element float array, [K11,K12,...,K33], specifying the 3x3 "
         "camera matrix for your imaging setup. Generated by oat-calibrate.")
        ("distortion-coeffs,d", po::value<std::string>(),
         "Five to eight element float array, [x1,x2,x3,...], specifying lens "
         "distortion coefficients. Generated by oat-calibrate.")
        ("board-size,S", po::value<std::string>(),
         "Two element int array, [X,Y], specifying the dimensions of the Aruco "
         "board (the number of markers in the X and Y directions).")
        ("length,l", po::value<float>(),
         "Length, in meters, of each side of the square markers within the "
         "Aruco board.")
        ("separation,s", po::value<float>(),
         "Separation, in meters, between each of the markers within the "
         "Aruco board.")
        ("print,p",
         "Prior to performing position detection, print the specified Aruco "
         "board to a PNG file, named \'board.png\', in the current directory. "
         "The size of the generated image is determined by:\n\n"
         "  separation + length = 100 pixels")
        //("tune,t",
        // "if true, provide a gui with sliders for tuning detection "
        // "parameters.")
        ;

    opts.add(local_opts);

    // Return valid keys
    for (auto &o : local_opts.options())
        config_keys_.push_back(o->long_name());
}

void ArucoBoard::configure(const po::variables_map &vm)
{
    // Check for config file and entry correctness
    auto config_table = oat::config::getConfigTable(vm);
    oat::config::checkKeys(config_keys_, config_table);

    // Marker dictionary
    std::string dict_key = "4X4_50";
    oat::config::getValue<std::string>(vm, config_table, "dictionary", dict_key);
    auto dict = getBoardDictionary(dict_key);

    // Board dimensions
    std::vector<int> n {1, 1};
    if (oat::config::getArray<int, 2>(vm, config_table, "board-size", n)) {

        if (n[0] < 1 || n[1] < 1)
            throw std::runtime_error("Board size values must be positive integers.");

        if (n[0] * n[1] > dict->bytesList.rows) // bytesList.rows is dict size
            throw std::runtime_error("Board size is too large for selected dictionary.");
    }

    // Length
    float marker_length = 0.05;
    oat::config::getNumericValue<float>(vm, config_table, "length", marker_length, 0);

    // Separation
    float marker_separation = 0.01;
    oat::config::getNumericValue<float>(vm, config_table, "separation", marker_separation, 0);

    // TODO: User detection configuration?
    detection_params_ = cv::aruco::DetectorParameters::create();

    // Create the board
    cv::Ptr<cv::aruco::GridBoard> grid_board =
        cv::aruco::GridBoard::create(n[0],
                                     n[1],
                                     marker_length,
                                     marker_separation,
                                     dict);
    board_ = grid_board.staticCast<cv::aruco::Board>();

    // Print board to file
    bool print_board = false;
    oat::config::getValue<bool>(vm, config_table, "print", print_board);
    if (print_board) {
        cv::Mat board_img;
        grid_board->draw(cv::Size(n[0] * 100, n[1] * 100), board_img);
        cv::imwrite("board.png", board_img);
    }

    // Calculate offset to middle of grid
    // TODO: Seems to have a slight offset for some reason
    auto nx = static_cast<float>(n[0]) / 2.0;
    auto ny = static_cast<float>(n[1]) / 2.0;
    origin_.x = nx * marker_length + (nx - 1) * marker_separation
                + marker_length / 6; // TODO: Num pixels + 2
    origin_.y = ny * marker_length + (ny - 1) * marker_separation
                + marker_length / 6;
    origin_.z = 0;

    // TODO: Remove
    ref_pts_.push_back(origin_);
    ref_pts_.push_back(corner_);

    if (oat::config::getArray<double>(
            vm, config_table, "distortion-coeffs", dist_coeff_)) {

        if (dist_coeff_.size() < 5 || dist_coeff_.size() > 8)
            throw (std::runtime_error("Distortion coefficients consist of 5 to 8 values."));
    }

    // Camera Matrix
    std::vector<double> K;
    if (oat::config::getArray<double, 9>(vm, config_table, "camera-matrix", K)) {

        camera_matrix_(0, 0) = K[0];
        camera_matrix_(0, 1) = K[1];
        camera_matrix_(0, 2) = K[2];
        camera_matrix_(1, 0) = K[3];
        camera_matrix_(1, 1) = K[4];
        camera_matrix_(1, 2) = K[5];
        camera_matrix_(2, 0) = K[6];
        camera_matrix_(2, 1) = K[7];
        camera_matrix_(2, 2) = K[8];
    }
}

void ArucoBoard::detectPosition(cv::Mat &frame, oat::Position2D &position)
{

    // Dummy pose for now
    oat::Pose pose;

    // First detect markers
    std::vector<int> marker_ids;
    std::vector<std::vector<cv::Point2f>> marker_corners;
    auto parameters = cv::aruco::DetectorParameters::create();
    cv::aruco::detectMarkers(frame,
                             board_->dictionary,
                             marker_corners,
                             marker_ids,
                             detection_params_);

    // Next try to estimate pose
    if (marker_ids.size() > 0) {

        // TODO: Remove
        cv::aruco::drawDetectedMarkers(frame, marker_corners, marker_ids);

        cv::Vec3d rvec, tvec;
        int valid = cv::aruco::estimatePoseBoard(marker_corners,
                                                 marker_ids,
                                                 board_,
                                                 camera_matrix_,
                                                 dist_coeff_,
                                                 rvec, tvec);
        if (valid) {

            // Strategy 1
            // Find origin
            //auto trans = cv::Affine3f(rvec, tvec);
            //auto origin = trans * origin_;

            // Strategy 2
            cv::Mat R;
            cv::Rodrigues(rvec, R);
            auto origin = R * origin_ + tvec;

            // Strategy 3
            //cv::Project

            //Gererate position
            //position.position_valid = true;
            //position.position.x = origin.x;
            //position.position.y = origin.y;
            
            // 
            pose.position_valid = true;
            pose.position.x = origin.x;
            pose.position.y = origin.y;
            pose.position.z = origin.z;

            // Heading is defined as the angle between a corner and the center
            // of the board +90 degrees
            //auto dx = origin.x - corner.x;
            //auto dy = origin.y - corner.y;
            //auto theta = std::atan2(dy, dx);//  + 0.75 * oat::PI;

            //position.heading_valid = true;
            //position.heading.x = std::cos(theta);
            //position.heading.y = std::sin(theta);

            pose.heading_valid = true;
            pose.rvec(0) = rvec[0];
            pose.rvec(1) = rvec[1];
            pose.rvec(2) = rvec[2];
            pose.tvec(0) = tvec[0];
            pose.tvec(1) = tvec[1];
            pose.tvec(2) = tvec[2];


            //TODO: All plotting stuff below here, remove
            std::vector<cv::Point2f> xy;
            cv::projectPoints(ref_pts_,
                              rvec,
                              tvec,
                              camera_matrix_,
                              dist_coeff_,
                              xy);


            cv::circle(frame, xy[0], 10, cv::Scalar(0, 255, 0), 2);
            cv::aruco::drawAxis(frame, camera_matrix_, dist_coeff_, rvec, tvec, 1);

            // Serialize the current position
            rapidjson::StringBuffer buffer;
            rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
            pose.Serialize(writer);
            std::cout << buffer.GetString() << std::flush;

            //std::string text;
            //text = std::to_string(57.3 * theta);
            //cv::putText(frame, text, cv::Point2d(10 30), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 0 255), 2);
        }
    }
}

cv::Ptr<cv::aruco::Dictionary> getBoardDictionary(const std::string &key)
{
    std::map<std::string, int> dict_map {
        {"4X4_50"  , cv::aruco::DICT_4X4_50  },
        {"4X4_100" , cv::aruco::DICT_4X4_100 },
        {"4X4_250" , cv::aruco::DICT_4X4_250 },
        {"4X4_1000", cv::aruco::DICT_4X4_1000},
        {"5X5_50"  , cv::aruco::DICT_5X5_50  },
        {"5X5_100" , cv::aruco::DICT_5X5_100 },
        {"5X5_250" , cv::aruco::DICT_5X5_250 },
        {"5X5_1000", cv::aruco::DICT_5X5_1000},
        {"6X6_50"  , cv::aruco::DICT_6X6_50  },
        {"6X6_100" , cv::aruco::DICT_6X6_100 },
        {"6X6_250" , cv::aruco::DICT_6X6_250 },
        {"6X6_1000", cv::aruco::DICT_6X6_1000},
        {"7X7_50"  , cv::aruco::DICT_7X7_50  },
        {"7X7_100" , cv::aruco::DICT_7X7_100 },
        {"7X7_250" , cv::aruco::DICT_7X7_250 },
        {"7X7_1000", cv::aruco::DICT_7X7_1000}
    };

    try {
        return cv::aruco::getPredefinedDictionary(dict_map.at(key));
    } catch (const std::out_of_range &ex) {
        throw std::runtime_error("Unknown aruco board dictionary.");
    }
}

} /* namespace oat */
