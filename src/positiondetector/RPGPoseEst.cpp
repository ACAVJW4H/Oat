//******************************************************************************
//* File:   RPGPoseEst.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//****************************************************************************

#include "RPGPoseEst.h"

#include <cmath>
#include <cpptoml.h>
#include <opencv2/aruco.hpp>
#include <opencv2/cvconfig.h>
#include <opencv2/opencv.hpp>
#include <string>

#include "../../lib/utility/IOFormat.h"
#include "../../lib/utility/TOMLSanitize.h"

namespace oat {

RPGPoseEst::RPGPoseEst(const std::string &frame_source_address,
                       const std::string &position_sink_address)
: PositionDetector(frame_source_address, position_sink_address)
{
    // Set required frame type
    required_color_ = PIX_GREY;
}

po::options_description RPGPoseEst::options() const
{
    // Update CLI options
    po::options_description local_opts;
    local_opts.add_options()
        ("marker-positions,M",po::value<std::string>(),
         "Nx3 element array of 3D marker positions in meters.")
        ("threshold,T",po::value<int>(),
         "Detection threshold value, 0-256. Defaults to 100.")
        ("gauss-sigma,s",po::value<double>(),
         "Sigma of Gaussian blur filter. Defaults to 0.6.")
        ("area,a", po::value<std::string>(),
         "Array of floats, [min,max], specifying the minimum and maximum "
         "object contour area in pixels^2. Defaults to [10,200].")
        ("width-height-dist,w",po::value<double>(),
         "Minimum ratio of width-to-height of a bounding box around a detected "
         "blob. Ideally the ratio of the width to the height of the bounding "
         "rectangle should be 1. Defaults to 0.5.")
        ("circ-dist,c",po::value<double>(),
         "Maximum allowable distortion, 0 to 1.0, of a bounding box around the "
         "detected blob, calculated as the area of the blob divided by pi times "
         "half the height or half the width of the bounding rectangle. Defaults "
         "to 0.5.")
        ("back-proj-tol,b",po::value<double>(),
         "Maximum allowable back projection tolerance, in pixels, to consider a "
         "projected point to correspond to the detected point in the captured "
         "image. Defaults to 5.")
        ("nn-pixel-tol,n",po::value<double>(),
         "Tolerance, in pixels, that determines the correspondences between the "
         "LEDs and the detections in the image when predicting the position of "
         "the LEDs in the image. Defaults to 7.")
        ("pose-cert-thresh,C",po::value<double>(),
         "Minimum ratio of how many of the back-projected points must be within "
         "the 'back-proj-tol' for a correspondence between the LEDs and the "
         "detections to be correct. Defaults to 0.75.")
        ("pose-corr-thresh,p", po::value<double>(),
         "Minimum correspondence ratio, 0 to 1.0, to continue with smart pose "
         "estimation rather than brute-force correspondence search. Defaults to "
         "0.7.")
        ("roi-border,r", po::value<unsigned int>(),
         "Thickness of the border (in pixels) around the predicted area of the "
         "LEDs in the image that defines the region of interest for image "
         "detection of the LEDs in the next frame. Defaults to 20.")
        ("camera-matrix,k", po::value<std::string>(),
         "Nine element float array, [K11,K12,...,K33], specifying the 3x3 "
         "camera matrix for your imaging setup. Generated by oat-calibrate.")
        ("distortion-coeffs,d", po::value<std::string>(),
        "Five to eight element float array, [x1,x2,x3,...], specifying lens "
        "distortion coefficients. Generated by oat-calibrate.")
        ("tune,t",
         "if true, provide a gui with sliders for tuning detection "
         "parameters.")
        ;
    return local_opts;
}

void RPGPoseEst::applyConfiguration(const po::variables_map &vm,
                                    const config::OptionTable &config_table)
{
    // Marker Positions
    std::vector<double> mp;
    if (oat::config::getArray<double>(
            vm, config_table, "marker-positions", mp, true)) {

        if ((mp.size() % 3) != 0) {
            throw std::runtime_error(
                "Marker positions must be an Nx3 matrix.");
        }

        auto num_markers = mp.size() / 3;
        if (num_markers < 4) {
            throw std::runtime_error(
                "At least 4 marker positions are required.");
        }

        mpe::List4DPoints marker_positions;
        marker_positions.resize(num_markers);
        for (size_t i = 0; i < num_markers; i++) {
            auto s = i * 3;
            Eigen::Matrix<double, 4, 1> pt{mp[s], mp[s + 1], mp[s + 2], 1};
            marker_positions(i) = pt;
        }

        tracker_.setMarkerPositions(marker_positions);
    }

    // Detection Thresh
    tracker_.detection_threshold_value_ = 140;
    oat::config::getNumericValue<int>(vm,
                                      config_table,
                                      "threshold",
                                      tracker_.detection_threshold_value_,
                                      0,
                                      256);
    // Gaussian Sigma
    tracker_.gaussian_sigma_ = 0.6;
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "gauss-sigma",
                                         tracker_.gaussian_sigma_,
                                         0,
                                         10);
    // Min/max object area
    tracker_.min_blob_area_ = 10;
    tracker_.max_blob_area_ = 200;
    std::vector<double> area;
    if (oat::config::getArray<double, 2>(vm, config_table, "area", area)) {

        tracker_.min_blob_area_ = area[0];
        tracker_.max_blob_area_ = area[1];

        if (area[0] >= area[1])
           throw std::runtime_error("Max area should be larger than min area.");
    }

    // Max width/height distortion
    tracker_.max_width_height_distortion_ = 0.5;
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "width-height-dist",
                                         tracker_.max_width_height_distortion_,
                                         0,
                                         1.0);
    // Max circular distortion
    tracker_.max_circular_distortion_ = 0.5;
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "circ-dist",
                                         tracker_.max_circular_distortion_,
                                         0,
                                         1.0);

    // ROI thickness
    tracker_.roi_border_thickness_ = 20;
    oat::config::getNumericValue<unsigned int>(
        vm, config_table, "roi-border", tracker_.roi_border_thickness_, 0);

    // Nearest neighbor pixel tolerance
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "nn-pixel-tol",
                                         tracker_.nearest_neighbour_pixel_tolerance_,
                                         0,
                                         20);

    // Back projection tolerance
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "back-proj-tol",
                                         tracker_.back_projection_pixel_tolerance_,
                                         0,
                                         20);
    // Certainty threshold
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "pose-cert-thresh",
                                         tracker_.certainty_threshold_,
                                         0,
                                         1.0);

    // Correspondence threshold
    oat::config::getNumericValue<double>(vm,
                                         config_table,
                                         "pose-corr-thresh",
                                         tracker_.valid_correspondence_threshold_,
                                         0,
                                         1.0);

    // Distortion Coefficients
    if (oat::config::getArray<double>(
            vm, config_table, "distortion-coeffs", dist_coeff_, true)) {

        if (dist_coeff_.size() < 5 || dist_coeff_.size() > 8) {
            throw(std::runtime_error(
                "Distortion coefficients consist of 5 to 8 values."));
        }
    }

    // Camera Matrix
    std::vector<double> K;
    if (oat::config::getArray<double, 9>(
            vm, config_table, "camera-matrix", K, true)) {

        camera_matrix_(0, 0) = K[0];
        camera_matrix_(0, 1) = K[1];
        camera_matrix_(0, 2) = K[2];
        camera_matrix_(1, 0) = K[3];
        camera_matrix_(1, 1) = K[4];
        camera_matrix_(1, 2) = K[5];
        camera_matrix_(2, 0) = K[6];
        camera_matrix_(2, 1) = K[7];
        camera_matrix_(2, 2) = K[8];
    }

    tracker_.camera_matrix_K_ = cv::Mat(camera_matrix_);

    // Tuning GUI
    oat::config::getValue<bool>(vm, config_table, "tune", tuning_on_);

    if (tuning_on_) {

        TUNE<int>(&tracker_.detection_threshold_value_,
                  "Detection thresh. (px)",
                  0,
                  256,
                  tracker_.detection_threshold_value_,
                  1);

        TUNE<double>(&tracker_.gaussian_sigma_,
                     "Gauss. sigma (px * 10)",
                     0.10,
                     10.0,
                     tracker_.gaussian_sigma_,
                     10.0);

        TUNE<double>(&tracker_.min_blob_area_,
                     "Min area(px^2)",
                     0.0,
                     OAT_POSIDET_MAX_OBJ_AREA_PIX,
                     tracker_.min_blob_area_,
                     1.0);

        TUNE<double>(&tracker_.max_blob_area_,
                     "Max area(px^2)",
                     0.0,
                     OAT_POSIDET_MAX_OBJ_AREA_PIX,
                     tracker_.max_blob_area_,
                     1.0);

        TUNE<double>(&tracker_.max_width_height_distortion_,
                     "Max Width/height distortion (%)",
                     0.0,
                     1.0,
                     tracker_.max_width_height_distortion_,
                     100.0);

        TUNE<double>(&tracker_.max_circular_distortion_,
                     "Max circular distortion (%)",
                     0.0,
                     1.0,
                     tracker_.max_circular_distortion_,
                     100.0);

        TUNE<unsigned int>(&tracker_.roi_border_thickness_,
                     "ROI border thickeness (px)",
                     0,
                     100,
                     tracker_.roi_border_thickness_,
                     1);

        TUNE<double>(&tracker_.nearest_neighbour_pixel_tolerance_,
                     "Nearest neighbor pixel tol. (px)",
                     1.0,
                     20.0,
                     tracker_.nearest_neighbour_pixel_tolerance_,
                     1.0);

        TUNE<double>(&tracker_.back_projection_pixel_tolerance_,
                     "Back proj. pixel tol. (px)",
                     1.0,
                     20.0,
                     tracker_.back_projection_pixel_tolerance_,
                     1.0);

        TUNE<double>(&tracker_.certainty_threshold_,
                     "Certainty thresh (%)",
                     0.0,
                     1.0,
                     tracker_.certainty_threshold_,
                     100.0);

        TUNE<double>(&tracker_.valid_correspondence_threshold_,
                     "Valid correspondance thresh (%)",
                     0.0,
                     1.0,
                     tracker_.valid_correspondence_threshold_,
                     100.0);
    }
}

oat::Pose RPGPoseEst::detectPose(oat::Frame &frame)
{
    oat::Pose pose(
        Pose::DistanceUnit::Meters, Pose::DOF::Three, Pose::DOF::Three);

    // Pose will be in meters
    pose.unit_of_length = Pose::DistanceUnit::Meters;

    // Detect pose
    auto t = frame.sample().seconds().count();
    std::cout << t << " seconds" << std::endl;
    auto found = tracker_.estimateBodyPose(frame, t);

    if (tuning_on_) {
        cv::cvtColor(frame, tuning_frame_, cv::COLOR_GRAY2BGR);
        tracker_.augmentImage(tuning_frame_);
    }

    if (found) {

        Eigen::Matrix4d transform = tracker_.getPredictedPose();
        Eigen::Matrix3d R = transform.block<3, 3>(0, 0);
        Eigen::Vector3d T = transform.block<3, 1>(0, 3);

        // Set pose
        pose.found = true;
        pose.set_position<Eigen::Vector3d>(T);
        pose.set_orientation<Eigen::Matrix3d>(R);
    }

    return pose;
}

} /* namespace oat */
