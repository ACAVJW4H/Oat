//******************************************************************************
//* File:   PositionWriter.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//*****************************************************************************

#include "OatConfig.h" // Generated by CMake

#include "PositionWriter.h"

#include <cassert>

#include "../../lib/utility/FileFormat.h"

namespace oat {

PositionWriter::PositionWriter(const std::string &addr)
: Writer(addr)
{
    // Nothing
}

PositionWriter::~PositionWriter()
{
    json_writer_.EndArray();
    json_writer_.EndObject();
    file_stream_->Flush();
}

void PositionWriter::configure(const oat::config::OptionTable &t,
                               const po::variables_map &vm)
{
    // File overwrite
    oat::config::getValue(vm, t, "allow-overwrite", allow_overwrite_);

    // Compression level
    oat::config::getValue(vm, t, "concise-file", concise_file_);
}

void PositionWriter::initialize(const std::string &path)
{
    auto full_path =  path + ".json";

    if (!allow_overwrite_)
       oat::ensureUniquePath(full_path);

    if (!oat::checkWritePermission(full_path))
        throw std::runtime_error("Write permission denied for " + full_path);

    // Position file
    fd_ = fopen(full_path.c_str(), "wb");

    // File descriptor must be available for writing
    assert(fd_);

    file_stream_.reset(new rapidjson::FileWriteStream(
            fd_,
            position_write_buffer,
            sizeof(position_write_buffer)));
    json_writer_.Reset(*file_stream_);

    // Main object, end this object before write flush in destructor
    json_writer_.StartObject();

    // Oat version
    char version[255];
    strcpy (version, Oat_VERSION_MAJOR);
    strcat (version, ".");
    strcat (version, Oat_VERSION_MINOR);
    json_writer_.String("oat_version");
    json_writer_.String(version);

    // Header object
    json_writer_.String("header");

    json_writer_.StartObject();
    json_writer_.String("date");
    json_writer_.String(oat::createTimeStamp(true).c_str());

    double fs = 1 / sample_period_sec();
    json_writer_.String("sample_rate_hz");
    if (std::isfinite(fs))
        json_writer_.Double(fs);
    else
        json_writer_.Double(-1.0);

    // End header
    json_writer_.EndObject();

    // Start data object
    json_writer_.String("positions");
    json_writer_.StartArray();
}

void PositionWriter::write() {

    oat::Position2D p("");

    while (buffer_.pop(p))
        p.Serialize(json_writer_, !concise_file_);
}

void PositionWriter::push() {

    if (!buffer_.push(source_.clone()))
        throw std::runtime_error(overrun_msg);
}

} /* namespace oat */
