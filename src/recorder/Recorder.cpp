//******************************************************************************
//* File:   Recorder.cpp
//* Author: Jon Newman <jpnewman snail mit dot edu>
//*
//* Copyright (c) Jon Newman (jpnewman snail mit dot edu)
//* All right reserved.
//* This file is part of the Oat project.
//* This is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* This software is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* You should have received a copy of the GNU General Public License
//* along with this source code.  If not, see <http://www.gnu.org/licenses/>.
//*****************************************************************************

#include "OatConfig.h" // Generated by CMake

#include <chrono>
#include <ctime>
#include <iomanip>
#include <mutex>
#include <string.h>
#include <string>
#include <vector>

#include <sys/stat.h>
#include <boost/filesystem.hpp>
#include <boost/dynamic_bitset.hpp>

#include "../../lib/utility/make_unique.h"
#include "../../lib/shmemdf/SharedFrameHeader.h"

#include "Recorder.h"

namespace oat {

namespace bfs = boost::filesystem;

Recorder::Recorder(const std::vector<std::string> &position_source_addresses,
                   const std::vector<std::string> &frame_source_addresses,
                   std::string save_path,
                   std::string file_name,
                   const bool prepend_date,
                   const int frames_per_second,
                   bool overwrite) :
  save_path_(save_path)
, file_name_(file_name)
, append_date_(prepend_date)
, allow_overwrite_(overwrite)
, frames_per_second_(frames_per_second)
, sources_eof(false) {

    // First check that the save_path is valid
    bfs::path path(save_path.c_str());
    if (!bfs::exists(path) || !bfs::is_directory(path)) {
        std::cout << "Warning: requested recording path, " + save_path + ", "
                  << "does not exist, or is not a valid directory.\n"
                  << "attempting to use the current directory instead.\n";
        save_path = bfs::current_path().c_str();
    }

    // Start recorder name construction
    name_ = "recorder[" ;

    // Create recording timestamp
    std::time_t raw_time;
    struct tm * time_info;
    char buffer[100];
    std::time(&raw_time);
    time_info = std::localtime(&raw_time);
    std::strftime(buffer, 80, "%F-%H-%M-%S", time_info);
    std::string date_now = std::string(buffer);

    // Setup position sources
    if (!position_source_addresses.empty()) {

        name_ += position_source_addresses[0];
        if (position_source_addresses.size() > 1)
            name_ += "..";

        for (auto &addr : position_source_addresses) {

            oat::Position2D pos(addr);
            positions_.push_back(std::move(pos));
            position_write_number_.push_back(0);
            position_sources_.push_back(std::make_pair(addr,
                    std::make_unique<oat::Source < oat::Position2D >> () ));
        }

        // Create a single position file
        std::string posi_fid;
        if (prepend_date)
            posi_fid = file_name.empty() ?
            (save_path + "/" + date_now + "_" + position_source_addresses[0]) :
            (save_path + "/" + date_now + "_" + file_name);
        else
            posi_fid = file_name.empty() ?
            (save_path + "/" + position_source_addresses[0]) :
            (save_path + "/" + file_name);

        posi_fid = posi_fid + ".json";

        if (!allow_overwrite_) {
            checkFile(posi_fid);
        }

        position_fp = fopen(posi_fid.c_str(), "wb");
        if (!position_fp)
            throw (std::runtime_error("Error: unable to open, " + posi_fid + ".\n"));

        file_stream_.reset(new rapidjson::FileWriteStream(position_fp,
                position_write_buffer, sizeof(position_write_buffer)));
        json_writer_.Reset(*file_stream_);

        // Main object, end this object before write flush
        json_writer_.StartObject();

        // Coordinate system
        char version[255];
        strcpy (version, Oat_VERSION_MAJOR);
        strcat (version, ".");
        strcat (version, Oat_VERSION_MINOR);
        json_writer_.String("oat_version");
        json_writer_.String(version);

        // Complete header object
        json_writer_.String("header");
        writePositionFileHeader(date_now, frames_per_second, position_source_addresses);

        // Start data object
        json_writer_.String("positions");
        json_writer_.StartArray();
    }

    // Create a video writer, file, and buffer for each image stream
    uint32_t idx = 0;
    if (!frame_source_addresses.empty()) {

        if (!position_source_addresses.empty())
            name_ += ", ";

        name_ += frame_source_addresses[0];
        if (frame_source_addresses.size() > 1)
            name_ += "..";

        for (auto &addr : frame_source_addresses) {

            // Generate file name for this video
            std::string frame_fid;
            if (prepend_date)
                frame_fid = file_name.empty() ?
                (save_path + "/" + date_now + "_" + addr) :
                (save_path + "/" + date_now + "_" + file_name + "_" + addr);
            else
                frame_fid = file_name.empty() ?
                (save_path + "/" + addr) :
                (save_path + "/" + file_name);

            frame_fid = frame_fid + ".avi";

            if (!allow_overwrite_)
                checkFile(frame_fid);

            video_file_names_.push_back(frame_fid);

            frame_sources_.push_back(std::make_pair(
                    addr, std::make_unique<oat::Source < oat::SharedFrameHeader >> ()
            ));

            frame_write_buffers_.push_back(std::make_unique<FrameQueue>());

            video_writers_.push_back(std::make_unique<cv::VideoWriter>());

            // Spawn frame writer threads and synchronize to incoming data
            frame_write_mutexes_.push_back(std::make_unique<std::mutex>());

            frame_write_condition_variables_.push_back(
                std::make_unique<std::condition_variable>()
            );

            frame_write_threads_.push_back(
                std::make_unique<std::thread>(
                    &Recorder::writeFramesToFileFromBuffer, this, idx++
                )
            );
        }
    }

    name_ +="]";
}

Recorder::~Recorder() {

    // Set running to false to trigger thread join
    running = false;
    for (auto &value : frame_write_condition_variables_)
        value->notify_one();

    // Join all threads
    for (auto &value : frame_write_threads_)
        value->join();

    // Flush the position writer
    if (position_fp != nullptr) {
        json_writer_.EndArray();
        json_writer_.EndObject();
        file_stream_->Flush();
    }
}

void Recorder::connectToNodes() {

    // Connect to frame source nodes
    for (auto &fs: frame_sources_)
        fs.second->connect(fs.first);

    // Connect to position source nodes
    for (auto &ps : position_sources_)
        ps.second->connect(ps.first);
}

bool Recorder::writeStreams() {

    // Read frames
    for (fvec_size_t i = 0; i !=  frame_sources_.size(); i++) {

         // START CRITICAL SECTION //
        ////////////////////////////
        sources_eof |= frame_sources_[i].second->wait() == oat::NodeState::END;

        // Push newest frame into client N's queue
        if (!frame_write_buffers_[i]->push(frame_sources_[i].second->clone()))
            throw (std::runtime_error("Frame buffer overrun. Decrease the frame "
                                      "rate or get a faster hard-disk."));

        frame_sources_[i].second->post();
        ////////////////////////////
        //  END CRITICAL SECTION  //

        // Notify a writer thread that there is new data in the queue
        frame_write_condition_variables_[i]->notify_one();
    }

    // Read positions
    for (psvec_size_t i = 0; i !=  position_sources_.size(); i++) {

        // START CRITICAL SECTION //
        ////////////////////////////
        sources_eof |= position_sources_[i].second->wait() == oat::NodeState::END;

        position_write_number_[i] = position_sources_[i].second->write_number();
        positions_[i] = position_sources_[i].second->clone();

        position_sources_[i].second->post();
        ////////////////////////////
        //  END CRITICAL SECTION  //
    }

    // Push frames to buffers
    // Write the frames to file
    writePositionsToFile();

    return sources_eof;
}

void Recorder::writeFramesToFileFromBuffer(uint32_t writer_idx) {

    cv::Mat m;
    while (running) {

        std::unique_lock<std::mutex> lk(*frame_write_mutexes_[writer_idx]);
        frame_write_condition_variables_[writer_idx]->wait_for(lk, std::chrono::milliseconds(10));

        while (frame_write_buffers_[writer_idx]->pop(m)) {

            if (!video_writers_[writer_idx]->isOpened()) {
                initializeWriter(*video_writers_[writer_idx],
                        video_file_names_.at(writer_idx),
                        m);
            }

            video_writers_[writer_idx]->write(m);
        }
    }
}

void Recorder::writePositionsToFile() {

    if (position_fp) {

        json_writer_.StartObject();

        for (pvec_size_t i = 0; i !=  positions_.size(); i++) {
            json_writer_.String(positions_[i].label());
            positions_[i].Serialize(json_writer_);
        }

        json_writer_.EndObject();
    }
}

void Recorder::writePositionFileHeader(const std::string& date,
                                       const double sample_rate,
                                       const std::vector<std::string>& sources) {

    json_writer_.StartObject();

    json_writer_.String("date");
    json_writer_.String(date.c_str());

    json_writer_.String("sample_rate_hz");
    json_writer_.Double(sample_rate);

    json_writer_.String("position_sources");
    json_writer_.StartArray();
    for (auto &s : sources) {
        json_writer_.String(s.c_str());
    }
    json_writer_.EndArray();

    json_writer_.EndObject();

}

void Recorder::initializeWriter(cv::VideoWriter& writer,
                                const std::string  &file_name,
                                const oat::Frame &image) {

    // Initialize writer using the first frame taken from server
    int fourcc = CV_FOURCC('H', '2', '6', '4');
    writer.open(file_name, fourcc, frames_per_second_, image.size());
}

bool Recorder::checkFile(std::string& file) {

    int i = 0;
    std::string original_file = file;
    bool file_exists = false;

    while (bfs::exists(file.c_str())) {

        ++i;
        bfs::path path(original_file.c_str());
        bfs::path parent_path = path.parent_path();
        bfs::path stem = path.stem();
        bfs::path extension = path.extension();

        std::string append = "_" + std::to_string(i);
        stem += append.c_str();

        // Recreate file name
        file = std::string(parent_path.generic_string()) +
                "/" +
                std::string(stem.generic_string()) +
                std::string(extension.generic_string());

    }

    if (i != 0) {
        file_exists = true;
    }

    return file_exists;
}

} /* namespace oat */
